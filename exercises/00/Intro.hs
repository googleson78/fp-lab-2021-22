module Intro where

-- TODO: > whoami
-- Georgi Lyubenov, he/him, contact info in readme
-- ben4a?

-- TODO: administrivia - georgi look at README!
-- ask about vax, live or remote if possible
-- ask about git knowledge

-- TODO: exposition
-- garbage collection
-- expressive static types
-- sum types
-- pattern matching!
-- functions! higher-order functions
-- lazy - a boon and a curse

-- no arbitrary IO
-- no mutations
-- value/"pipeline" oriented (give bash example maybe)

-- no null everywhere
-- concise, very modular

-- all in all - the language allows you to make it harder for yourself to write garbage
-- very enjoyable to work with - I'm dumb and so I let my compiler do most of my work for me
-- used for things that **really** shouldn't break :) - e.g. banks (standard chartered), military :(

-- disadvantages
-- not ultra popular:
-- * harder to get a job
-- * some libraries might be outdated/not extremely optimised
-- * there aren't obvious "best ways" to do things sometimes
-- learning curve is very steep at the beginning - especially when you ~~have been abused~~
-- are coming from an "imperative" and/or untyped background
-- used a lot for cryptoBS - third biggest crypto is in hs

-- myths
-- not a silver bullet
-- it's still a tool, and tools require proper usage (https://pbs.twimg.com/media/E7Kc0OhVUAAV0xz?format=jpg&name=small)
-- monads aren't hard (in haskell), they're only scary sounding
