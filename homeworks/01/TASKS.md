## Обвързване, интерпретация и компилация

# TODO: use "оценка" everywhere

По време на час видяхме следния тип, изразяващ структурата (абстрактно синтактично дърво)
на "език за прости сметки":

```haskell
data Expr
  = Val Integer
  | Plus Expr Expr
  | Mult Expr Expr
  | If Expr Expr Expr
```

Конструкторите "съответстваха" на следните операции:
* `Val n` - сметка, чийто резултат е числото `n`
* `Plus e1 e2` - сметка, чийто резултат е сбора на резултатите
    от сметките `e1` и `e2`
* `Mult e1 e2` - сметка, чийто резултат е произведението на резултатите
    от сметките `e1` и `e2`
* `If cex tex eex` - сметка, чийто резултат е `tex`, ако резултатът на `cex`
    е `0`, и `eex`, в противен случай

Това "съответствие" по-конкретно изразихме като направихме "интерпретатор" за
`Expr`, пресмятащ стойност по израз:
```haskell
eval :: Expr -> Integer
eval (Val n) = n
eval (Plus e1 e2) = eval e1 + eval e2
eval (Mult e1 e2) = eval e1 * eval e2
eval (If cex tex eex) =
  eval $
    if eval cex == 0
    then tex
    else eex

-- Примери
-- > eval $ Val 5
-- 5
-- > eval $ Plus (Val 6) (Val 7)
-- 13
-- > eval $ Mult (Val 6) (Val 7)
-- 42
-- > eval $ If (Val 3) (Val 6) (Mult (Val 3) (Val 3))
-- 9
```
Интерпретатор е програма, която изпълнява код, без да се налага да го превежда до
машинен език преди това.

Целта в това домашно ще е да направим следните разширения към нашия "език":
* добавяне на променливи, както и конструкция която "свързва" променлива
* добавяне на компилатор(/транспилатор) от езика към друг език
* имплементиране на оптимизация върху езика, която можем да приложим преди да компилираме

Компилатор най-често наричаме програма, която превежда един език в друг.
По-специфично, често под "компилатор" се има предвид "превежда до машинен код",
а пък под "транспилатор" се има предвид "до друг език от високо ниво"
(например `JavaScript`).

## Разширение на `Expr`

Ще разширим `Expr` типа с няколко допълнителни конструктора:

```haskell
data Expr
  = Var String
  | Val Integer
  | Oper Oper Expr Expr
  | If Expr Expr Expr
  | SumList [Expr]
  | Sum String Expr Expr
```
`Val` и `If` запазват семантиката си. Новите конструктори имат следната:
* `Var str` е **променлива** - идеята тук е че имаме име (т.е. низ), което ще **свържем**
    със стойност, чрез някакво външно средство. При интерпретация, това ще се случва
    когато при изпълнение, даваме `Integer`-и за стойности за всяка променлива, за която
    е нужно.
* `Oper` - конструктор който абстрахира над `Plus` и `Mult`, за да минимизираме дупликацията    на код - можем да видим че в `Plus` и `Mult` случаите на оригиналния `eval`,
    имплементацията е почти еднаква. Типът `Oper` ще дефинирате вие като задача.
* `SumList` - събираме резултата от пресмятането на списък от изрази
* `Sum i limex inside` - ще означава

    <img src="https://latex.codecogs.com/gif.latex?\sum_{i=0}^{limex}{inside}" />

    т.е. оценяваме `inside` многократно, като всеки път `i` свързваме с нова стойност,
    варираща от 0 до оценката на `limex`, и сумираме резултатите на всичките оценки на
    `inside`

    Напомням, че резултатът от сумирането на празен интервал,
    (т.е. ако оценката на `limex` се окаже по-малка от 0), е 0.

## `Context`
**Контекст** наричаме списък от наредени двойки от низ и цяло число. Или с други думи:
```haskell
type Context = [(String, Integer)]
```

Елемент на контекста ще наричаме **свързване**, защото свързва име на променлива със стойност.

"Разширяване на контекст" е добавяне на ново свързване към контекста, т.е.:

```haskell
extend :: String -> Integer -> Context -> Context
extend x n = ((x, n):)
```

Това разширяване естествено може да се случва където и да е, но се оказва удобно
то да е в началото му, за да може "по-нови" ("по-скорошни") свързвания, да са по-отпред
и съответно да намираме първо тях, когато има повече от едно свързване на дадена променлива
със стойност.

## Задачи

## Интерпретация

Първо - няколко помощни функции.

### `lookup`

Имплементирайте търсене на стойност по даден ключ.

Тук специализираме ключовете до низове, а търсенето в контекст,
така че ще връщаме цяло число.

Естествено, това име може да го няма в контекста, затова и връщаме `Maybe Integer`.

Примери:
```haskell
> lookup "x" [("x", 5), ("y", 6)]
Just 5
> lookup "z" [("x", 5), ("y", 6)]
Nothing
> lookup "x" [("x", 5), ("y", 6), ("x", 69)]
Just 5
```

### `maybeAndThen`

Функция, която абстрахира "работата в контекст на `Maybe`".

Често се налага когато имаме `Maybe` стойност, да "пропагираме" `Nothing` резултатите,
а пък при `Just`, да вземем някакво решение базирано на стойността вътре.

В общия случай операцията която ще прилагаме над стойността в `Just`-а също може да се провали,
заради което и функцията която се подава връща `Maybe` също.

Тази функция ще е удобна за `eval` например, където ще се наложи работа с повече `Maybe`
стойности.

Примери:

```haskell
> maybeAndThen (lookup "x" [("x", 5)]) (\xVal -> Just $ x * x)
Just 25
> maybeAndThen (lookup "x" [("y", 5)]) (\xVal -> Just $ x * x)
Nothing
> maybeAndThen (lookup "x" [("x", 5)]) (\xVal -> if even xVal then Just xVal else Nothing)
Nothing
> maybeAndThen (lookup "x" [("x", 6)]) (\xVal -> if even xVal then Just xVal else Nothing)
Just 6
> lookup "x" [("x", 5)] `maybeAndThen` \xVal -> Just $ x - 1
Just 4
```

Често е удобно тази функция да се използва инфиксно:
```haskell
ctxt = [("x", 6), ("y", 9)]

-- get the values of two variables from the context, failing if *any* of them are missing
-- examples:
-- > getTwo "x" "y" ctxt
-- Just (6,9)
-- > getTwo "y" "x" ctxt
-- Just (9,6)
-- > getTwo "x" "z" ctxt
-- Nothing
-- > getTwo "z" "y" ctxt
-- Nothing
getTwo :: String -> String -> Context -> Maybe (Integer, Integer)
getTwo x y ctxt =
  lookup x ctxt `maybeAndThen` \xVal ->
  lookup y ctxt `maybeAndThen` \yVal ->
  Just (xVal, yVal)
-- maybeAndThen is left-associative, so
-- mx `maybeAndThen` f `maybeAndThen` g
-- is actually
-- (mx `maybeAndThen` f) `maybeAndThen` g
-- (the other bracketing wouldn't type check anyway)
--
-- we could've instead written this as:
-- maybeAndThen
--   (lookup x ctxt)
--   (\xVal ->
--     maybeAndThen
--       (lookup y ctxt)
--       (\yVal -> Just (xVal, yVal)))
-- but the "infix hanging lambda" version is nicer for indentation,
-- and it's also very close to something else we'll encounter later
```

### `traverseListMaybe`

Функция която вече сме виждали на упражнение:

Имаме списък от `a`-та, както и функция, която връща `b`, но допускайки и провал `a -> Maybe b`.

Искаме да пробвмае да изпълним функцията за всичките елементи на списъка,
успявайки (т.е. връщайки `Just`), само резултатите на функцията върху всеки от елементите
на списъка е успяла (върнала `Just`).

За да можем да използваме и че наистина е успяла, връщаме резултатите от всичките извиквания.

Примери:
```haskell
> traverseListMaybe (\x -> if even x then Just (x * x) else Nothing) [2,4,6]
Just [4,16,36]
> traverseListMaybe (\x -> if even x then Just x else Nothing) [1,2,4]
Nothing
> traverseListMaybe (\x -> if even x then Just x else Nothing) [4,2,1]
Nothing
```

### "Обяснение" за свободни и свързани променливи

Интуитивно, свободни променливи са такива, които наистина са "неизвестни".

Свързаните променливи "зависят" от нещо - най-често "квантор".

Това което сте срещали
вие досега като примери за това са "за всяко", "съществува", "интеграл", "производна" -
във всички тези случаи, имаме променлива обвързана с квантора.

В нашия случай "кванторът" който имаме е `Sum` - в него се изисква име на променлива,
която да считаме за "свързана" във "вътрешния" израз на сумата.

Примери:
```haskell
Sum "i" (Val 5) (Var "x")
```
Тук `"x"` е свободна променлива.
```haskell
Sum "i" (Val 5) (Var "i")
```
Тук `"i"` е свързана променлива - тя даже не е "наистина" променлива, защото
гледайки че горната граница на сумата константа, можем да я премахнем, като
"разпишем" сумата до `0 + 1 + 2 + 3 + 4 + 5`.
```haskell
Sum "i" (Var "i") (Var "x")
```
Тук `"x"` е свободна променлива.
Тук `"i"`-то което имаме в горната граница на сумата **не е** свързана променлива - тя е свободна.

Не би било разумно да допускаме свързването в `Sum` да влияе на горната му граница,
защото тогава бихме имали много суми които се държат странно (например са константи винаги,
 зациклят безкрайно, винаги имат само един член на сумата).
```haskell
Sum "i" (Var "i") (Var "i")
```
Тук `"i"` е **и свързана и свободна** променлива.

Тя е свободна, от това че участва в горната грнаица на сумата, а е свързана, защото участва във вътрешния израз на сумата.


### `freeVars`

Намерете всичките свободни променливи на даден израз.

Примери
```haskell
> freeVars (If (Var "x") (Val 5) (Var "y"))
["x", "y"]
> freeVars (Sum "i" (Var "x") (If (Var "i") (Var "y") (Var "z")))
["x", "y", "z"]
> freeVars (Sum "i" (Var "i") (If (Var "i") (Var "y") (Var "z")))
["i", "y", "z"]
```

### `Oper`

Напишете `Oper` типа, така че да поддържа поне събиране и умножение.

В следващата задача за `eval` ще имплементиране и интерпретацията му като "двуместна функция".

### `eval`

Тъй като вече имаме променливи, ще трябва някакъв начин да им даваме стойности.

Това постигаме, като приемаме контекст в който ще интерпретираме израз:
```haskell
eval :: Expr -> Integer
-- ->
eval :: Context -> Expr -> Integer
```

Ще установим че добавеният контекст е ключов за `Sum` случая, независимо от това
дали в началото сме имали каквито и да е свободни променливи в израза.

Тъй като нямаме гаранция че всичките променливи в израз ще ги има в подадения контекст, трябва да позволим на `eval` да се проваля:
```haskell
eval :: Context -> Expr -> Integer
-- ->
eval :: Context -> Expr -> Maybe Integer
```

Имплементирайте новият `eval`.

Примери:
```haskell
> eval [] $ Var "x"
> Nothing
> eval [("x", 5), ("x", 6)] $ Var "x"
> Just 5

> eval [] (If (Val 0) (Val 6) (Val 9))
Just 6
> eval [] (If (Val 42) (Val 6) (Val 9))
Just 9
> eval [] (If (Val 0) (Val 6) (Var "x"))
Just 6
> eval [] (If (Val 42) (Var "x") (Val 9))
Just 9
> eval [] (If (Var "x") (Val 6) (Val 9))
Nothing
> eval [("x", 0)] (If (Var "x") (Val 6) (Val 9))
Just 6

> eval [] (SumList [Val 5, Val 6, Val 7])
Just 18
> eval [] (SumList [Val 5, Val 6, Var "x"])
Nothing
> eval [("x", 5)] (SumList [Val 5, Val 6, Var "x"])
Just 16

> eval [] (Sum "i" (Val 10) (Val 1))
Just 11
> eval [] (Sum "i" (Val 10) (Var "i"))
Just 55
> eval [] (Sum "i" (Val 10) (Var "x"))
Nothing
> eval [("x", 2)] (Sum "i" (Val 10) (Var "x"))
Just 22
> eval [] (Sum "i" (Val (-1)) (Var "y"))
Just 0
> eval [("i", 69)] (Sum "i" (Val 10) (Var "i"))
Just 55
> eval [] (Sum "i" (Var "i") (Var "i"))
Nothing
> eval [("i", 10)] (Sum "i" (Var "i") (Var "i"))
Just 55
> eval [] (Sum "i" (Val 2) (Sum "i" (Val 10) (Var "i")))
Just 165
```

## Компилация
Второ - още няколко помощни функции.

### `intersperse`

Вмъкнете символ между всеки два елемента на подадени списък:

Примери:
```haskell
> intersperse 42 [1,2,3]
[1,42,2,42,3]
> intersperse 42 [1]
[1]
> intersperse 42 []
[]
```

### `unwords`

Слива списък от низове, слагайки празни места помежду тях.

Казва се `unwords`, защото има `words`, което от низ прави списък от низове разбити по празните места.

Примери:
```haskell
> unwords []
""
> unwords ["Pirin"]
"Pirin"
> unwords ["Pirin", "ate", "the", "pizza!"]
"Pirin ate the pizza!"
```

### `unlines`

Слива списък от думи, слагайки нови редове помежду тях.

Казва се `unlines`, защото има `lines`, което от низ прави списък от низове разбити по нови редове.

Примери:
```haskell
> unlines []
""
> unlines ["Pirin"]
"Pirin"
> unlines ["Pirin", "ate", "the", "pizza!"]
"Pirin\nate\nthe\npizza!"
```
